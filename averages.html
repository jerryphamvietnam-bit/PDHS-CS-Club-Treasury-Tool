<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Charts from Transactions</title>
  <script type="text/javascript" src="https://www.gstatic.com/charts/loader.js"></script>
  <style>
    body {
      background-color: #1F1F1F;
      color: #C1C1C1;
      text-align: left;
    }
    h1, p {
      color: #C1C1C1;
    }
  </style>
</head>
<body>

<h1>Averages</h1>
<p>Pie chart and line chart automatically generated from transactions</p>

<div id="piechart" style="width: 900px; height: 500px;"></div>
<div id="curve_chart" style="width: 900px; height: 500px;"></div>

<script type="text/javascript">
  google.charts.load('current', {'packages':['corechart']});
  google.charts.setOnLoadCallback(drawCharts);

  // parse date string robustly: supports YYYY-MM-DD, MM/DD/YYYY, or falls back to Date()
  function parseDate(dateStr) {
    if (!dateStr) return null;
    dateStr = String(dateStr).trim();
    // YYYY-MM-DD (or YYYY-M-D)
    if (/^\d{4}-\d{1,2}-\d{1,2}$/.test(dateStr)) {
      const parts = dateStr.split('-').map(p => parseInt(p, 10));
      return new Date(parts[0], parts[1] - 1, parts[2]);
    }
    // MM/DD/YYYY or M/D/YYYY
    if (/^\d{1,2}\/\d{1,2}\/\d{4}$/.test(dateStr)) {
      const parts = dateStr.split('/').map(p => parseInt(p, 10));
      return new Date(parts[2], parts[0] - 1, parts[1]);
    }
    // Try ISO / timestamp fallback
    const d = new Date(dateStr);
    return isNaN(d.getTime()) ? null : d;
  }

  function drawCharts() {
    drawPieChart();
    drawLineChart();
  }

  function drawPieChart() {
    let transactions = JSON.parse(localStorage.getItem("transactions")) || [];

    let totals = {};
    transactions.forEach(t => {
      // ensure amount numeric
      const amt = typeof t.amount === 'number' ? t.amount : parseFloat(t.amount) || 0;
      if (!totals[t.type]) totals[t.type] = 0;
      totals[t.type] += amt;
    });

    let chartData = [['Type', 'Amount']];
    for (let type in totals) {
      chartData.push([type, totals[type]]);
    }

    const data = google.visualization.arrayToDataTable(chartData);

    const options = {
      title: 'Transactions by Type',
      backgroundColor: '#1F1F1F',
      titleTextStyle: { color: '#C1C1C1' },
      legendTextStyle: { color: '#C1C1C1' }
    };

    const chart = new google.visualization.PieChart(document.getElementById('piechart'));
    chart.draw(data, options);
  }

  function drawLineChart() {
    let transactions = JSON.parse(localStorage.getItem("transactions")) || [];

    // Map and parse dates, filter invalid
    const parsed = transactions
      .map(t => {
        const d = parseDate(t.date);
        const amt = typeof t.amount === 'number' ? t.amount : parseFloat(t.amount) || 0;
        return { original: t, dateObj: d, amount: amt, type: t.type };
      })
      .filter(x => x.dateObj && !isNaN(x.dateObj.getTime())); // only valid dates

    if (parsed.length === 0) {
      // no valid data â€” draw an empty chart with original behavior
      const emptyData = google.visualization.arrayToDataTable([['Date','Balance ($)']]);
      const emptyOptions = {
        title: 'Balance Over Time',
        curveType: 'function',
        legend: { position: 'bottom' },
        backgroundColor: '#1F1F1F',
        titleTextStyle: { color: '#C1C1C1' },
        legendTextStyle: { color: '#C1C1C1' },
        hAxis: { title: 'Date', textStyle: { color: '#C1C1C1' }, titleTextStyle: { color: '#C1C1C1' } },
        vAxis: { title: 'Balance ($)', textStyle: { color: '#C1C1C1' }, titleTextStyle: { color: '#C1C1C1' } }
      };
      const chart = new google.visualization.LineChart(document.getElementById('curve_chart'));
      chart.draw(emptyData, emptyOptions);
      return;
    }

    // Sort by parsed date (oldest -> newest)
    parsed.sort((a, b) => a.dateObj.getTime() - b.dateObj.getTime());

    // Build DataTable explicitly using Date type (avoids categorical x-axis)
    const dataTable = new google.visualization.DataTable();
    dataTable.addColumn('date', 'Date');
    dataTable.addColumn('number', 'Balance ($)');

    let balance = 0;
    const rows = [];
    parsed.forEach(item => {
      if (item.type === 'Funding' || String(item.type).toLowerCase() === 'funding') balance += item.amount;
      else balance -= item.amount;
      rows.push([ item.dateObj, balance ]);
    });

    dataTable.addRows(rows);

    // Axis padding: add small padding so points aren't flush with edge
    const first = rows[0][0].getTime();
    const last = rows[rows.length - 1][0].getTime();
    const range = Math.max(1, last - first);
    const pad = Math.max(24*60*60*1000, Math.round(range * 0.03)); // 1 day or 3% of range

    const options = {
      title: 'Balance Over Time',
      curveType: 'function',
      legend: { position: 'bottom' },
      backgroundColor: '#1F1F1F',
      titleTextStyle: { color: '#C1C1C1' },
      legendTextStyle: { color: '#C1C1C1' },
      hAxis: {
        title: 'Date',
        format: 'MMM dd',   // readable
        textStyle: { color: '#C1C1C1' },
        titleTextStyle: { color: '#C1C1C1' },
        viewWindowMode: 'explicit',
        viewWindow: {
          min: new Date(first - pad),
          max: new Date(last + pad)
        }
      },
      vAxis: {
        title: 'Balance ($)',
        textStyle: { color: '#C1C1C1' },
        titleTextStyle: { color: '#C1C1C1' }
      }
    };

    const chart = new google.visualization.LineChart(document.getElementById('curve_chart'));
    chart.draw(dataTable, options);
  }

  // Refresh every second
  setInterval(drawCharts, 1000);
</script>

</body>
</html>
